      name: Prepare Deploy Plan

on:
  #  push:
  #    branches: [MCC-STG]
  workflow_dispatch:
    inputs:
      base_ref:
        description: "Base tag or commit (default: latest tag)"
        required: false
        type: string
      env:
        description: "chá»n mÃ´i trÆ°á»ng deploy"
        required: true
        type: choice
        options:
          - stg
          - prd

env:
  NAMESPACE: mcc
  ORDER: "1.config-server-service 2.auth-service 3.master-data-service 4.material-service 5.plan-service 6.gateway 7.frontend-service"
  WORKER_LABEL: "role=app"

jobs:
  init: 
    runs-on: [code-xlarge, code-linux]
    outputs:
      branch_deploy: ${{ steps.set.outputs.branch }}
      APP_ROOT: ${{ steps.set.outputs.deploy_dir }}
    steps:
      - name: toa bien moi truong
        id: set
        run: |
          ENV = "${{github.event.inputs.env}}"
          
          if ["$ENV" = "prd"]; then
            echo "branch_deploy=main" >> $GITHUB_OUTPUT
            echo "APP_ROOT=2.prd/1.moss-app" >> $GITHUB_OUTPUT   

          elif ["$ENV" = "stg"]; then
            echo "branch_deploy=MCC-STG" >> $GITHUB_OUTPUT
            echo "APP_ROOT=1.stg/1.moss-app"/1.moss-app" >> $GITHUB_OUTPUT   

          else
            echo "Invalid env: $ENV"
            exit 1
          fi

  resolve-base:
    needs: init
    runs-on: [code-xlarge, code-linux]
    outputs:
      base_ref: ${{ steps.base.outputs.base_ref }}
    steps:
      - uses: actions/checkout@v4
        ref: ${{steps.set.outputs.branch}}
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{steps.set.outputs.branch}}
      - id: base
        run: |
          echo"APP_ROOT: ${{ steps.set.outputs.deploy_dir }}"
          if [ -n "${{ github.event.inputs.base_ref }}" ]; then
            BASE="${{ github.event.inputs.base_ref }}"
            echo "âœ” Using input base_ref: $BASE"
          else
            BASE=$(git describe --tags --abbrev=0 2>/dev/null || git rev-list --max-parents=0 HEAD)
            echo "âœ” Using latest tag: $BASE"
          fi
          git rev-parse "$BASE"
          echo "base_ref=$BASE" >> $GITHUB_OUTPUT

  detect-folders:
    needs: [resolve-base,init]
    runs-on: [code-xlarge, code-linux]
    outputs:
      folders: ${{ steps.diff.outputs.folders }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - id: diff
        run: |
          set -e

          BASE="${{ needs.resolve-base.outputs.base_ref }}"
          echo"APP_ROOT: ${{ steps.set.outputs.deploy_dir }}"
          echo "===== [JOB1] Diff from $BASE â†’ HEAD ====="
          FILES=$(git diff --name-only "$BASE" HEAD || true)
          echo "$FILES"

          APP_FILES=$(echo "$FILES" | grep '^"$APP_ROOT" ' || true)

          FOLDERS=$(echo "$APP_FILES" \
            | cut -d/ -f3 \
            | sort -u \
            | jq -R -s -c 'split("\n")[:-1]' || echo '[]')

          echo "Detected folders:"
          echo "$FOLDERS" | jq .

          echo "folders=$FOLDERS" >> $GITHUB_OUTPUT
  collect-images:
    needs: [detect-folders,init]
    if: needs.detect-folders.outputs.folders != '[]'
    runs-on: [self-hosted, stg]
    outputs:
      images: ${{ steps.collect.outputs.images }}

    steps:
      - uses: actions/checkout@v4
        ref: ${{steps.set.outputs.branch}}
      - id: collect
        run: |
          set -e
          echo"APP_ROOT: ${{ steps.set.outputs.deploy_dir }}"
          echo "===== [JOB2] Collect images from changed folders ====="
          echo '${{ needs.detect-folders.outputs.folders }}' | jq .

          IMAGES=()

          for dir in $ORDER; do
            echo '${{ needs.detect-folders.outputs.folders }}' \
              | jq -e ".[] | select(.==\"$dir\")" >/dev/null || continue

            DEPLOY="1.stg/1.moss-app/$dir/1.deploy.yaml"
            [ ! -f "$DEPLOY" ] && continue

            IMAGE=$(yq e '.spec.template.spec.containers[].image' "$DEPLOY")
            echo "âœ” $dir â†’ $IMAGE"
            IMAGES+=("$IMAGE")
          done

          printf '%s\n' "${IMAGES[@]}" | sort -u > images.txt
          jq -R -s -c 'split("\n")[:-1]' images.txt > images.json

          echo "images=$(cat images.json)" >> $GITHUB_OUTPUT

  prepull-images:
    needs: [collect-images,init]
    if: needs.collect-images.outputs.images != '[]'
    runs-on: [self-hosted, stg]

    steps:
      - uses: actions/checkout@v4
        ref: ${{steps.set.outputs.branch}}
      - name: Pre-pull images on worker nodes (role=app)
        run: |
          set -e
          echo"APP_ROOT: ${{ steps.set.outputs.deploy_dir }}"
          echo "===== [JOB3] Images from Job2 ====="
          echo '${{ needs.collect-images.outputs.images }}' | jq .
          echo

          echo "===== [JOB3] Worker nodes (role=app) ====="
          NODES=$(kubectl get nodes -l role=app \
            -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}')

          if [ -z "$NODES" ]; then
            echo "âŒ No worker node with label role=app found"
            exit 1
          fi

          echo "$NODES"
          echo

          for node in $NODES; do
            echo "----- Checking node: $node -----"

            for image in $(echo '${{ needs.collect-images.outputs.images }}' | jq -r '.[]'); do
              echo "ðŸ” Image: $image"

              if ssh -i /home/scloud/.ssh/share-key scloud@stg-worker01 "sudo crictl images | awk '{print \$1\":\"\$2}' | grep -qx $image" ; then 
                  echo true
              else
                ssh -i /home/scloud/.ssh/share-key scloud@$node "sudo ctr -n k8s.io i pull -u ${{ secrets.TOKEN_PULL_IMAGE }} $image"
                  echo false
              fi

            done
          done

          echo
          echo "===== [JOB3] Image pre-pull completed successfully ====="

  generate-plan:
    needs: [resolve-base, detect-folders,init]
    runs-on: [self-hosted, stg]
    outputs:
      final_plan: ${{ steps.plan.outputs.final_plan }}
    steps:
      - uses: actions/checkout@v4
        ref: ${{steps.set.outputs.branch}}
      - name: Checkout source
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # =========================
      # 1ï¸âƒ£ Debug inputs
      # =========================
      - name: Debug detected folders
        run: |
          echo "BASE_REF=${{ needs.resolve-base.outputs.base_ref }}"
          echo "DETECTED_FOLDERS=${{ needs.detect-folders.outputs.folders }}"
          echo"APP_ROOT: ${{ steps.set.outputs.deploy_dir }}"

      # =========================
      # 2ï¸âƒ£ Generate PLAN
      # =========================
      - name: Generate deployment PLAN (DEBUG, ORDERED)
        shell: bash
        run: |
          set -euo pipefail

          BASE="${{ needs.resolve-base.outputs.base_ref }}"
          DETECTED_FOLDERS='${{ needs.detect-folders.outputs.folders }}'
          
          NAMESPACE="mcc"
          PLAN_FILE="$RUNNER_TEMP/deploy.plan" 
          : > "$PLAN_FILE"
          echo "## ðŸ§¾ DEPLOY PLAN (base=$BASE)" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          # ===== Iterate ORDER but ONLY when folder is detected =====
          for dir in $ORDER; do
            if ! echo "$DETECTED_FOLDERS" | jq -e ".[] | select(.==\"$dir\")" >/dev/null; then
              echo "â­ Skip $dir (not in detected_folders)"
              continue
            fi

            echo "ðŸ“‚ Processing $dir"
            echo "### ðŸ“‚ $dir" >> "$GITHUB_STEP_SUMMARY"

            cd "$APP_ROOT/$dir"

            DEPLOY_NAME=""
            DEPLOY_CHANGED=false
            OTHER_CHANGED=false

            # ===== Collect files =====
            DEPLOY_FILE=""
            NON_DEPLOY_FILES=()

            for f in $(ls *.yaml | sort); do
              if [ "$f" = "1.deploy.yaml" ]; then
                DEPLOY_FILE="$f"
              else
                NON_DEPLOY_FILES+=("$f")
              fi
            done

            echo "âž¡ NON-deploy files: ${NON_DEPLOY_FILES[*]}"
            echo "âž¡ Deploy file: ${DEPLOY_FILE:-none}"

            # ===== Phase 1: NON-deploy =====
            for f in "${NON_DEPLOY_FILES[@]}"; do
              if git diff "$BASE" HEAD -- "$f" | grep . >/dev/null; then
                echo "   âœ” $f changed â†’ apply"
                OTHER_CHANGED=true
                CMD="kubectl apply -f $APP_ROOT/$dir/$f -n $NAMESPACE"
                echo "- $CMD" >> "$GITHUB_STEP_SUMMARY"
                echo "$CMD"  >> "$PLAN_FILE"
              else
                echo "   âœ˜ $f unchanged"
              fi
            done

            # ===== Phase 2: deploy LAST =====
            if [ -n "$DEPLOY_FILE" ]; then
              DEPLOY_NAME=$(yq e '.metadata.name' "$DEPLOY_FILE")

              if git diff "$BASE" HEAD -- "$DEPLOY_FILE" | grep . >/dev/null; then
                echo "   âœ” deploy.yaml changed â†’ apply"
                DEPLOY_CHANGED=true
                CMD="kubectl apply -f $APP_ROOT/$dir/$DEPLOY_FILE -n $NAMESPACE"
                echo "- $CMD" >> "$GITHUB_STEP_SUMMARY"
                echo "$CMD"  >> "$PLAN_FILE"
              else
                echo "   âœ˜ deploy.yaml unchanged"
              fi
            fi
            # ===== Phase 3: restart =====
            if [ "$DEPLOY_CHANGED" = false ] && [ "$OTHER_CHANGED" = true ]; then
              echo "   ðŸ” restart deployment/$DEPLOY_NAME"
              CMD="kubectl rollout restart deployment/$DEPLOY_NAME -n $NAMESPACE"
              echo "- $CMD" >> "$GITHUB_STEP_SUMMARY"
              echo "$CMD"  >> "$PLAN_FILE"
            fi

            cd - >/dev/null
            echo "" >> "$GITHUB_STEP_SUMMARY"
          done
          # =========================
          # 4ï¸âƒ£ Final one-line PLAN
          # =========================
          FINAL_PLAN=$(paste -sd ';' "$PLAN_FILE")

          echo ""
          echo "=============================="
          echo "ðŸ”— FINAL ORDERED PLAN (1 LINE)"
          echo "=============================="
          echo "$FINAL_PLAN"

          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "## ðŸ”— FINAL PLAN (1 LINE)" >> "$GITHUB_STEP_SUMMARY"
          echo '```bash' >> "$GITHUB_STEP_SUMMARY"
          echo "$FINAL_PLAN" >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"

          # export output
          echo "final_plan=$FINAL_PLAN" >> "$GITHUB_OUTPUT"
